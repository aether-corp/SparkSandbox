```java

public class Sum {

    /**
     * Finds if there are two elements that total sum
     * 
     * @param array
     * 
     * @param sum
     * 
     * @return true if there are two elements in array that
     * total sum
     * 
     * Examples
     *   sum({1,3,5,6}, 9) --> true
     *   sum({1,3,5,6}, 4) --> true
     *   sum({1,3,5,6}, 10) --> false
     *   sum({1,3,4,6}, 6) --> false
     *   sum({1,3,8,6,3}, 6) --> true
     */
    public boolean sum(int[] array, int sum) {
        
        
    }
}

/* Not order
O (N)

def getSum(array: Array[Int], t
```

```scala
/*
 * This Scala source file was generated by the Gradle 'init' task.
 */
package gradle.spark.quickstart.fixed
import java.time.Instant
import java.util.UUID
import java.util.concurrent.atomic.AtomicInteger
import gradle.spark.quickstart.{AnimalWeighingService, SparkApp, fixed}
import org.apache.spark.rdd.RDD
import org.apache.spark.sql.{Row, SparkSession}

/**
 *
 * The implementation below currently fails. We are looking for the candidate to submit a
 * working solution to the currently buggy code with some explanation as below.
 * a. What is the issue.
 * b. What is your thought process while addressing the issue.
 * c. Some explanation on your solution.
 *
 */
case class AnimalTestResult(animal: String, score: Int)
/**
 * Uses predictive model to estimate average weight of any type of animal.
 */
object AnimalWeighingService extends Serializable {
  import java.util.concurrent.CopyOnWriteArrayList
  val activeSessions = new CopyOnWriteArrayList[String]()
  var nextScore = new AtomicInteger()
  def establishSession: String = {
    val session = UUID.randomUUID().toString
    activeSessions.add(session)
    Thread.sleep(100)
    val time = Instant.now.toEpochMilli
    System.out.println(Thread.currentThread().getName +   " returning session at:" + time);
    session
  }
  def testSubjectAndReportScore(sessionId: String, animal: String): Int = {
    if (!activeSessions.contains(sessionId)) {
      throw new IllegalArgumentException(s"Invalid session: $sessionId")
    }
    nextScore.incrementAndGet()
  }
}
object FixedSparkApp {
  def main(args: Array[String]): Unit = {
    val (cores, partitions) = ("1", 1)
    val spark: SparkSession = SparkSession
      .builder()
      .appName("test")
      .master(s"local[$cores]")
      .getOrCreate()
    import spark.implicits._
    val animalsRdd: RDD[Row] = {
      (1 to 23).map(i => s"dog-${i}").toList.toDF("animalType").rdd
    }
    val sumOfScores = {
      val startTime = Instant.now.toEpochMilli
      val sum = calculateSumOfScores(partitions, animalsRdd)
      val endTime = Instant.now.toEpochMilli
      val result: Long = (endTime - startTime)
      if (result > 2000) {
        throw new RuntimeException("Too slow !  Queue of animals to be tested may overflow. And animals will be sad !")
      }
      sum
    }
    System.out.println("sumOfScores :" + sumOfScores);
    assert(sumOfScores == 276)
  }

  private def calculateSumOfScores(partitions: Int, animalsRdd: RDD[Row]) = {
    val results: RDD[fixed.AnimalTestResult] = animalsRdd.repartition(partitions).map { row => 
      println(s"THE row is $row / and first element is ${row.get(0).toString}")
      val animal = row.get(0).toString
      val sessionId = AnimalWeighingService.establishSession
      fixed.AnimalTestResult(animal, AnimalWeighingService.testSubjectAndReportScore(sessionId, animal))
    }
    results.collect().map(_.score).sum
  }
}
```
```SQL

CREATE TABLE Persons (
    PersonID int,
    LastName varchar(255),
    FirstName varchar(255),
    Address varchar(255),
    City varchar(255)
);


- Write query to show how many  persons exists in each city

SELECT City, Count(PersonID)
FROM Persons
GROUP BY City

CREATE TABLE Hobby (
    PersonID int,
    Hobby varchar(255)
);

- Write query with Persons to Hobby relation, 
  show all persons even if they don't have a hobby

SELECT p.PersonID, h.Hobby
FROM Persons p
LEFT JOIN Hobby h ON p.PersonID = h.PersonID 
```

```scala

/**
 * Finds if there are two elements that total sum
 *
 * @param array
 * @param sum
 * @return true if there are two elements in array that
 * total sum
 *
 * Examples
 *   sum({1,3,5,6}, 9) --> true
 *   sum({1,3,5,6}, 4) --> true
 *   sum({1,3,5,6}, 10) --> false
 *   sum({1,3,4,6}, 6) --> false
 *   sum({1,3,8,6,3}, 6) --> true
 *
 *   checkSumIsInArray(vector = Vector(1,3,5,6) n = 9)
 *   checkSumTR(remaining = v(1,3,5,6), lum().
 *    remaining.isEmpty = F,
 *      lookUpMap.contains(9 - 1 = 8) = F
 *   checkSumTR(remaining = v(3,5,6), lum(1 -> 1).
 *    remaining.isEmpty = F,
 *      lookUpMap.contains(9 - 3 = 6) = F
 *   checkSumTR(remaining = v(5,6), lum(1 -> 1, 3 -> 1).
 *    remaining.tail.isEmpty = F,
 *      lookUpMap.contains(9 - 5 = 4) = F
 *   checkSumTR(remaining = v(6), lum(1 -> 1, 3 -> 1, 5 -> 1).
 *    remaining.tail.isEmpty = T,
 *      lookUpMap.contains(9 - 5 = 4) = F
 */

//val vec2 = Vector()
//vec2.isEmpty
//val vec = Vector(1,3,5,6)
//vec.contains(4)
//vec.contains(5)

def checkSumIsInArray (vector: Vector[Int], n: Int): Boolean = {
    def checkSumTR(remaining: Vector[Int], lookUpMap: Map[Int, Int]): Boolean = {
      if (lookUpMap.contains(n - remaining.head)) true
      else if (remaining.tail.isEmpty) false
      else checkSumTR(remaining.tail, lookUpMap + (remaining.head -> 1) )
    }

   checkSumTR(vector, Map())
}

checkSumIsInArray(Vector(1,3,5,6), 9) //--> true
checkSumIsInArray(Vector(1,3,5,6), 4) //--> true
checkSumIsInArray(Vector(1,3,5,6), 10) //--> false
checkSumIsInArray(Vector(1,3,4,6), 6) //--> false
checkSumIsInArray(Vector(1,3,8,6,3), 6) //--> true

checkSumIsInArray(Vector(1,3,2,6), 6) //--> false
checkSumIsInArray(Vector(1,12,34,434,11,3,3), 6) //--> true
checkSumIsInArray(Vector(1,12,-34,434,11,3,-3,9), 6) //--> true
/*
res0: Boolean = true
res1: Boolean = true
res2: Boolean = false
res3: Boolean = false
res4: Boolean = true

res5: Boolean = false
res6: Boolean = true
res7: Boolean = true
 */
```