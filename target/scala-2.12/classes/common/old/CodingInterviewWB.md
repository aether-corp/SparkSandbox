```java

public class Sum {

    /**
     * Finds if there are two elements that total sum
     * 
     * @param array
     * 
     * @param sum
     * 
     * @return true if there are two elements in array that
     * total sum
     * 
     * Examples
     *   sum({1,3,5,6}, 9) --> true
     *   sum({1,3,5,6}, 4) --> true
     *   sum({1,3,5,6}, 10) --> false
     *   sum({1,3,4,6}, 6) --> false
     *   sum({1,3,8,6,3}, 6) --> true
     */
    public boolean sum(int[] array, int sum) {
        
        
    }
}

/* Not order
O (N)

def getSum(array: Array[Int], t
```

```scala
/*
 * This Scala source file was generated by the Gradle 'init' task.
 */
package gradle.spark.quickstart.fixed
import java.time.Instant
import java.util.UUID
import java.util.concurrent.atomic.AtomicInteger
import gradle.spark.quickstart.{AnimalWeighingService, SparkApp, fixed}
import org.apache.spark.rdd.RDD
import org.apache.spark.sql.{Row, SparkSession}

/**
 *
 * The implementation below currently fails. We are looking for the candidate to submit a
 * working solution to the currently buggy code with some explanation as below.
 * a. What is the issue.
 * b. What is your thought process while addressing the issue.
 * c. Some explanation on your solution.
 *
 */
case class AnimalTestResult(animal: String, score: Int)
/**
 * Uses predictive model to estimate average weight of any type of animal.
 */
object AnimalWeighingService extends Serializable {
  import java.util.concurrent.CopyOnWriteArrayList
  val activeSessions = new CopyOnWriteArrayList[String]()
  var nextScore = new AtomicInteger()
  def establishSession: String = {
    val session = UUID.randomUUID().toString
    activeSessions.add(session)
    Thread.sleep(100)
    val time = Instant.now.toEpochMilli
    System.out.println(Thread.currentThread().getName +   " returning session at:" + time);
    session
  }
  def testSubjectAndReportScore(sessionId: String, animal: String): Int = {
    if (!activeSessions.contains(sessionId)) {
      throw new IllegalArgumentException(s"Invalid session: $sessionId")
    }
    nextScore.incrementAndGet()
  }
}
object FixedSparkApp {
  def main(args: Array[String]): Unit = {
    val (cores, partitions) = ("1", 1)
    val spark: SparkSession = SparkSession
      .builder()
      .appName("test")
      .master(s"local[$cores]")
      .getOrCreate()
    import spark.implicits._
    val animalsRdd: RDD[Row] = {
      (1 to 23).map(i => s"dog-${i}").toList.toDF("animalType").rdd
    }
    val sumOfScores = {
      val startTime = Instant.now.toEpochMilli
      val sum = calculateSumOfScores(partitions, animalsRdd)
      val endTime = Instant.now.toEpochMilli
      val result: Long = (endTime - startTime)
      if (result > 2000) {
        throw new RuntimeException("Too slow !  Queue of animals to be tested may overflow. And animals will be sad !")
      }
      sum
    }
    System.out.println("sumOfScores :" + sumOfScores);
    assert(sumOfScores == 276)
  }

  private def calculateSumOfScores(partitions: Int, animalsRdd: RDD[Row]) = {
    val results: RDD[fixed.AnimalTestResult] = animalsRdd.repartition(partitions).map { row => 
      println(s"THE row is $row / and first element is ${row.get(0).toString}")
      val animal = row.get(0).toString
      val sessionId = AnimalWeighingService.establishSession
      fixed.AnimalTestResult(animal, AnimalWeighingService.testSubjectAndReportScore(sessionId, animal))
    }
    results.collect().map(_.score).sum
  }
}
```
```SQL

CREATE TABLE Persons (
    PersonID int,
    LastName varchar(255),
    FirstName varchar(255),
    Address varchar(255),
    City varchar(255)
);


- Write query to show how many  persons exists in each city

SELECT City, Count(PersonID)
FROM Persons
GROUP BY City

CREATE TABLE Hobby (
    PersonID int,
    Hobby varchar(255)
);

- Write query with Persons to Hobby relation, 
  show all persons even if they don't have a hobby

SELECT p.PersonID, h.Hobby
FROM Persons p
LEFT JOIN Hobby h ON p.PersonID = h.PersonID 
```